<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Dodgeballs</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>



<body>
<script type="text/javascript">
	var ballStart = 10;
	var ballCount = 0;
	var ballYStart = 80;
	var speedFactor = 2.5;
	var player, balls;
	// var ballCountText, centerText;
	var gameRunning = false;
	var cursors; // for keyboard listener
	var timer;
	var elapsedTime = 0;


	// responsive design
	const gameWidth = window.innerWidth;
	const gameHeight = window.innerHeight;
	const ballRatio = (gameWidth/800 + gameHeight/600) / 3;
	const xStep = gameWidth / (ballStart + 1);
	const yStep = gameHeight / (ballStart + 1);
	console.log(`Window ${gameWidth} x ${gameHeight}`);
	console.log(ballRatio);


	// instantiate game
    var config = {
        type: Phaser.AUTO, //Phaser.WEBGL, or Phaser.CANVAS if WEBGL not available
		width: gameWidth,
		height: gameHeight,
		backgroundColor: 0xcccccc, // white
		physics: {
    		default: 'arcade',
        	arcade: {
            	gravity: { x: 0, y: 0 },
            	debug: false
        	}
    	},
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };
	var game = new Phaser.Game(config);
	document.body.style.cursor = 'none'; // hide pointer arrow


	// preload all assets
    function preload() {
		// images
		this.load.image('ball', 'assets/ball_sm.png');
		this.load.image('player', 'assets/player_sm.png');
		// sounds
		this.load.audio('bonk', 'assets/bonk.mp3');
		this.load.audio('newball', 'assets/newball.mp3');
		this.load.audio('dead', 'assets/dead.mp3');
    }



	function create() {
		// sounds
		this.bonkSound = this.sound.add('bonk');
		this.newballSound = this.sound.add('newball');
		this.deadSound = this.sound.add('dead');


		// physics objects
		// player
		// player = this.physics.add.sprite(400, 300, 'player');
		player = this.physics.add.image(gameWidth/2, gameHeight/2 + gameHeight/4, 'player'); // physics.add has Dynamic physics by default
		player.setScale(ballRatio);
		player.setCollideWorldBounds(true);
		player.body.setCircle(player.width/2); // circular hitbox

		player.body.setAllowGravity(false); // no gravity for player – NECESSARY?
		player.body.setImmovable(true); // NECESSARY?


		// balls
		balls = this.physics.add.group({
			key: 'ball', // texture
			repeat: ballStart - 1, // 1 created by default + X more = X+1 total
			setXY: { x: xStep, y: ballYStart, stepX: xStep, stepY: 0 }
		});
		balls.children.iterate(ball => {
			ballCount++;
			setBall(ball);
			ball.setVelocity(0, 0); // stop balls before game starts
		});


		// text output, default font = Courier
		this.ballCountText = this.add.text(16, 16, 'Count: ' + ballCount,
			{ fontSize: '20px', fill: '#000' }
		);
		this.timeText = this.add.text(200, 16, "Time: 0",
			{ fontSize: '20px', fill: '#000' }
		);
		this.centerText = this.add.text(gameWidth/2, gameHeight/2, 'click to begin',
			{ fontSize: '20px', fill: '#000', backgroundColor: "#ccc", align: 'center' }
		).setOrigin(0.5, 0.5); // center text


		// collision detection
		this.physics.add.collider(balls, balls, () => {
			this.bonkSound.play( { volume: 0.2, rate: 1.5 } );
		});
		// this.physics.add.collider(player, balls, endGame, null, this); // player=null (global), ball=this
		this.physics.add.collider(player, balls, () => {

			// end the game
			gameRunning = false;
			timer.remove();
			this.physics.pause(); // stop physics
			player.setTint(0x000000); // turn player black
			
			// this.input.enabled = false; // stop pointer events
			// this.input.keyboard.enabled = false; // stop keyboard input
			this.deadSound.play();
			this.centerText.setText("you lasted " + elapsedTime + " seconds\nyou reached " + ballCount + " balls\n\nclick to play again").setOrigin(0.5);

		}, null, this);


		// start after player clicks
        // ballsStarted = false;
        // this.input.once('pointerdown', startGame);
		this.input.on('pointerdown', () => {
			if (!gameRunning) {
				elapsedTime = 0;


				gameRunning = true;
				this.centerText.setText("");// centerText.destroy();
				player.clearTint(); // undo tint

				// reset player
				player.setPosition(gameWidth/2, gameHeight/2 + gameHeight/4);
				
				// reset balls
				let allBalls = balls.getChildren();
				for (let i = allBalls.length-1; i >= ballStart; i--) { // destroy added balls
					allBalls[i].destroy();
				}
				ballCount = balls.getChildren().length;

				let index = 0;
				balls.children.iterate(ball => {
					ball.x = xStep + index * xStep;
					ball.y = ballYStart;
					ball.setVelocity(
						Phaser.Math.Between(-(gameWidth/speedFactor), (gameWidth/speedFactor)),
						Phaser.Math.Between(-(gameWidth/speedFactor), (gameWidth/speedFactor)),
					);
					index++;
				});

				this.physics.resume(); // resume physics

				// track time
				elapsedTime = 0;
				timer = this.time.addEvent({
					delay: 1000,
					callback: () => {
						elapsedTime++;
						this.timeText.setText('Time: ' + elapsedTime);

						// release new ball
						if (elapsedTime % 10 == 0) {

							// create new ball
							ballCount++;
							this.ballCountText.setText('Count: ' + ballCount);

							var x = (player.x < gameWidth/2) ? Phaser.Math.Between(gameWidth/2 + gameWidth/4, gameWidth) : Phaser.Math.Between(0, gameWidth/4);

							var ball = balls.create(x, gameHeight/2, 'ball');
							setBall(ball);
							
							ball.setTint(0x00ff00);
							this.time.delayedCall(3000, () => { // remove tint
								ball.clearTint();
							});
							let halo = this.add.graphics();
							halo.lineStyle(30, 0x00ff00, 0.5); // thickness, color
							halo.strokeCircle(ball.x, ball.y, ball.width); // circle around player
							halo.setDepth(ball.depth - 1); // behind the ball
							// remove halo
							this.time.delayedCall(1000, () => {
								halo.destroy();
							});

							this.newballSound.play( { volume: 10, rate: 1 } );
						}
					},
					callbackScope: this,
					loop: true
				});

				// reset text outputs
				this.ballCountText.setText("Count: " + ballCount);
				this.timeText.setText('Time: 0');

			}
		});


		// trackpad listener
		this.input.on('pointermove', pointer => {
			if (!gameRunning) { return; }
			player.x = pointer.x;
			player.y = pointer.y;
		});
	}



    function update() {
	}



	// set ball properties
	function setBall(ball) {
		ball.setScale(ballRatio);
        ball.setCollideWorldBounds(true);
        ball.setBounce(1);
		ball.setVelocity(
			Phaser.Math.Between(-(gameWidth/speedFactor), (gameWidth/speedFactor)),
			Phaser.Math.Between(-(gameWidth/speedFactor), (gameWidth/speedFactor)),
		);
		ball.body.setCircle(ball.width/2); // circular hitbox
	}

</script>

</body>
</html>